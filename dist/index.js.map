{"version":3,"file":"index.js","sources":["../src/snapshot.js","../node_modules/.pnpm/@mercuryworkshop+wisp-js@0.3.3/node_modules/@mercuryworkshop/wisp-js/src/packet.mjs","../src/connection.js","../src/index.js"],"sourcesContent":["export const nativeWebSocket = WebSocket;\n","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw \"packet too small\";\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw \"invalid packet type\";\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw \"payload too small\";\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport const packet_classes = [\n  undefined,\n  ConnectPayload, \n  DataPayload, \n  ContinuePayload, \n  ClosePayload\n]\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81\n}","import { client as wisp } from \"@mercuryworkshop/wisp-js/client\";\n\nexport class wispWS {\n\tconstructor(uri) {\n\t\tthis.binaryType = \"blob\";\n\t\tthis.readyState = \"\";\n\t\tthis.url = uri;\n\t\tthis.eventListeners = [];\n\t\tthis.handshook = false;\n\t\tthis.loggedIn = false;\n\t\tthis.compression = -1;\n\t\tthis.eag2wispQueue = [];\n\t\tthis.username = \"___\";\n\t\tthis.ipPort = uri.slice(uri.lastIndexOf(\"/\") + 1).split(\":\", 2);\n\t\tif (this.ipPort.length < 2 || !+this.ipPort[1]) {\n\t\t\tthis.ipPort[1] = 25565;\n\t\t}\n\t\tthis.ipPort[1] = +this.ipPort[1];\n\t\tthis.wispStream = new oldWS(\n\t\t\t\"wss://anura.pro/\" + this.ipPort[0] + \":\" + this.ipPort[1]\n\t\t);\n\t\tthis.wispStream.binaryType = \"arraybuffer\";\n\t\tthis.wispStream.onclose = (event) => {\n\t\t\tthis.emit(\"close\", event.code);\n\t\t};\n\t\tthis.wispStream.onopen = () => {\n\t\t\tthis.emit(\"open\", {});\n\t\t};\n\t\tlet partialPacket = [];\n\t\tthis.wispStream.onmessage = async (event) => {\n\t\t\tawait navigator.locks.request(\"fart\", async () => {\n\t\t\t\tconst selfPacket = [...partialPacket, ...new Uint8Array(event.data)];\n\t\t\t\tpartialPacket = [];\n\t\t\t\tconst res = readVarInt(selfPacket);\n\t\t\t\tif (res.length < 2) {\n\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst packetLen = res[0];\n\t\t\t\tconst packetOff = res[1];\n\t\t\t\tif (selfPacket.length < packetOff + packetLen) {\n\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlet packetIdVI, packetId, packetIdOff, packet;\n\t\t\t\tif (this.compression >= 0) {\n\t\t\t\t\tconst dataLenVI = readVarInt(\n\t\t\t\t\t\tselfPacket.slice(packetOff, packetOff + packetLen)\n\t\t\t\t\t);\n\t\t\t\t\tif (dataLenVI.length < 2) {\n\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tlet dataLen = dataLenVI[0];\n\t\t\t\t\tconst dataLenOff = dataLenVI[1];\n\t\t\t\t\tconst compressedPacket = selfPacket.slice(\n\t\t\t\t\t\tpacketOff + dataLenOff,\n\t\t\t\t\t\tpacketOff + packetLen\n\t\t\t\t\t);\n\t\t\t\t\tif (compressedPacket.length != packetLen - dataLenOff) {\n\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst chunks = [];\n\t\t\t\t\tif (dataLen == 0) {\n\t\t\t\t\t\tdataLen = packetLen - dataLenOff;\n\t\t\t\t\t\tchunks.push(...compressedPacket);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst stream = new Blob([\n\t\t\t\t\t\t\tnew Uint8Array(compressedPacket),\n\t\t\t\t\t\t]).stream();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst decompressedStream = stream.pipeThrough(\n\t\t\t\t\t\t\t\tnew DecompressionStream(\"deflate\")\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tfor await (const chunk of decompressedStream) {\n\t\t\t\t\t\t\t\tchunks.push(...chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (chunks.length != dataLen) {\n\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpacketIdVI = readVarInt(chunks.slice(0, dataLen));\n\t\t\t\t\tif (packetIdVI.length < 2) {\n\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpacketId = packetIdVI[0];\n\t\t\t\t\tpacketIdOff = packetIdVI[1];\n\t\t\t\t\tpacket = chunks.slice(packetIdOff, dataLen);\n\t\t\t\t\tpartialPacket = selfPacket.slice(\n\t\t\t\t\t\tpacketOff + dataLenOff + compressedPacket.length\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tpacketIdVI = readVarInt(\n\t\t\t\t\t\tselfPacket.slice(packetOff, packetOff + packetLen)\n\t\t\t\t\t);\n\t\t\t\t\tif (packetIdVI.length < 2) {\n\t\t\t\t\t\tpartialPacket = selfPacket;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tpacketId = packetIdVI[0];\n\t\t\t\t\tpacketIdOff = packetIdVI[1];\n\t\t\t\t\tpacket = selfPacket.slice(\n\t\t\t\t\t\tpacketOff + packetIdOff,\n\t\t\t\t\t\tpacketOff + packetLen\n\t\t\t\t\t);\n\t\t\t\t\tpartialPacket = selfPacket.slice(packetOff + packetLen);\n\t\t\t\t}\n\t\t\t\tif (this.loggedIn) {\n\t\t\t\t\tif (packetId == 0x46) {\n\t\t\t\t\t\tthis.compression = readVarInt(packet)[0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.emit(\"message\", {\n\t\t\t\t\t\t\tdata: ba2ab([...makeVarInt(packetId), ...packet]),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else if (packetId == 0x03) {\n\t\t\t\t\tthis.compression = readVarInt(packet)[0];\n\t\t\t\t} else if (packetId == 0x02) {\n\t\t\t\t\tthis.emit(\"message\", { data: ba2ab([PROTOCOL_SERVER_FINISH_LOGIN]) });\n\t\t\t\t\tthis.loggedIn = true;\n\t\t\t\t\tfor (let p of this.eag2wispQueue) {\n\t\t\t\t\t\tconst vi = readVarInt(p);\n\t\t\t\t\t\tif (this.compression >= 0) {\n\t\t\t\t\t\t\tp = new Uint8Array(\n\t\t\t\t\t\t\t\tba2ab(\n\t\t\t\t\t\t\t\t\tawait makeCompressedPacket(\n\t\t\t\t\t\t\t\t\t\tvi[0],\n\t\t\t\t\t\t\t\t\t\tp.slice(vi[1]),\n\t\t\t\t\t\t\t\t\t\tthis.compression\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tp = new Uint8Array(ba2ab(makePacket(vi[0], p.slice(vi[1]))));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.wispStream.send(p);\n\t\t\t\t\t}\n\t\t\t\t\tthis.eag2wispQueue = [];\n\t\t\t\t} else if (packetId == 0x00) {\n\t\t\t\t\tthis.wispStream.close();\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t}\n\temit(ev, data) {\n\t\tev = ev.toLowerCase();\n\t\tif (this[\"on\" + ev]) {\n\t\t\tthis[\"on\" + ev](data);\n\t\t}\n\t\tif (this.eventListeners[ev]) {\n\t\t\tthis.eventListeners[ev].forEach((cb) => cb(data));\n\t\t}\n\t}\n\tclose(c) {\n\t\tif (this.wispStream) {\n\t\t\tthis.wispStream.close(c);\n\t\t}\n\t}\n\tasync send(p) {\n\t\tif (this.wispStream) {\n\t\t\tif (!this.handshook) {\n\t\t\t\tswitch (p[0]) {\n\t\t\t\t\tcase PROTOCOL_CLIENT_VERSION:\n\t\t\t\t\t\tthis.emit(\"message\", {\n\t\t\t\t\t\t\tdata: ba2ab([\n\t\t\t\t\t\t\t\tPROTOCOL_SERVER_VERSION,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t3,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t47,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PROTOCOL_CLIENT_REQUEST_LOGIN:\n\t\t\t\t\t\tconst bytes = p.slice(2, p[1] + 2);\n\t\t\t\t\t\tthis.username = new TextDecoder().decode(bytes);\n\t\t\t\t\t\t// in line below: need to replace the 16 bytes with OfflinePlayer:(username) UUID in form of 8-byte long MSB, 8-byte long LSB\n\t\t\t\t\t\tthis.emit(\"message\", {\n\t\t\t\t\t\t\tdata: ba2ab([\n\t\t\t\t\t\t\t\tPROTOCOL_SERVER_ALLOW_LOGIN,\n\t\t\t\t\t\t\t\tthis.username.length,\n\t\t\t\t\t\t\t\t...bytes,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PROTOCOL_CLIENT_PROFILE_DATA:\n\t\t\t\t\t\t// ignore for now\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase PROTOCOL_CLIENT_FINISH_LOGIN:\n\t\t\t\t\t\tthis.handshook = true;\n\t\t\t\t\t\tthis.wispStream.send(\n\t\t\t\t\t\t\tnew Uint8Array(\n\t\t\t\t\t\t\t\tba2ab(\n\t\t\t\t\t\t\t\t\tmakePacket(0x00, [\n\t\t\t\t\t\t\t\t\t\t...makeVarInt(47),\n\t\t\t\t\t\t\t\t\t\t...makeString(this.ipPort[0]),\n\t\t\t\t\t\t\t\t\t\t...makeShort(this.ipPort[1]),\n\t\t\t\t\t\t\t\t\t\t...makeVarInt(2),\n\t\t\t\t\t\t\t\t\t])\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.wispStream.send(\n\t\t\t\t\t\t\tnew Uint8Array(\n\t\t\t\t\t\t\t\tba2ab(makePacket(0x00, [...makeString(this.username)]))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.loggedIn) {\n\t\t\t\tconst vi = readVarInt(p);\n\t\t\t\tif (this.compression >= 0) {\n\t\t\t\t\tp = new Uint8Array(\n\t\t\t\t\t\tba2ab(\n\t\t\t\t\t\t\tawait makeCompressedPacket(\n\t\t\t\t\t\t\t\tvi[0],\n\t\t\t\t\t\t\t\tp.slice(vi[1]),\n\t\t\t\t\t\t\t\tthis.compression\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tp = new Uint8Array(ba2ab(makePacket(vi[0], p.slice(vi[1]))));\n\t\t\t\t}\n\t\t\t\tthis.wispStream.send(p);\n\t\t\t} else {\n\t\t\t\tthis.eag2wispQueue.push(p);\n\t\t\t}\n\t\t}\n\t}\n\taddEventListener(name, cb) {\n\t\tname = name.toLowerCase();\n\t\tif (this.eventListeners[name]) {\n\t\t\tthis.eventListeners[name].push(callback);\n\t\t} else {\n\t\t\tthis.eventListeners[name] = [cb];\n\t\t}\n\t}\n\tremoveEventListener(name, cb) {\n\t\tname = name.toLowerCase();\n\t\tif (this.eventListeners[name]) {\n\t\t\tif (cb && this.eventListeners[name].includes(cb)) {\n\t\t\t\tthis.eventListeners[name] = this.eventListeners[name].filter(\n\t\t\t\t\t(el) => el != cb\n\t\t\t\t);\n\t\t\t\tif (this.eventListeners[name].length == 0) {\n\t\t\t\t\tdelete this.eventListeners[name];\n\t\t\t\t}\n\t\t\t} else if (!cb) {\n\t\t\t\tdelete this.eventListeners[name];\n\t\t\t}\n\t\t}\n\t}\n}\n","import { nativeWebSocket } from \"./snapshot\";\nimport { wispWS } from \"./connection\";\nwindow.WebSocket = class {\n\tconstructor(uri, protos) {\n\t\tif ((\"\" + uri).toLowerCase().includes(\"://java://\")) {\n\t\t\tthis.impl = new wispWS(uri);\n\t\t} else {\n\t\t\tthis.impl = new nativeWebSocket(uri, protos);\n\t\t}\n\t}\n\tget binaryType() {\n\t\treturn this.impl.binaryType;\n\t}\n\tset binaryType(v) {\n\t\tthis.impl.binaryType = v;\n\t}\n\tget readyState() {\n\t\treturn this.impl.readyState;\n\t}\n\tget url() {\n\t\treturn this.impl.url;\n\t}\n\tset onopen(v) {\n\t\tthis.impl.onopen = v;\n\t}\n\tset onclose(v) {\n\t\tthis.impl.onclose = v;\n\t}\n\tset onmessage(v) {\n\t\tthis.impl.onmessage = v;\n\t}\n\tset onerror(v) {\n\t\tthis.impl.onerror = v;\n\t}\n\tclose(c) {\n\t\treturn this.impl.close(c);\n\t}\n\tsend(p) {\n\t\treturn this.impl.send(p);\n\t}\n\taddEventListener(p1, p2) {\n\t\treturn this.impl.addEventListener(p1, p2);\n\t}\n\tremoveEventListener(p1, p2) {\n\t\treturn this.impl.removeEventListener(p1, p2);\n\t}\n};\n"],"names":["nativeWebSocket","WebSocket","text_encoder","TextEncoder","encode","bind","text_decoder","TextDecoder","decode","wispWS","constructor","uri","this","binaryType","readyState","url","eventListeners","handshook","loggedIn","compression","eag2wispQueue","username","ipPort","slice","lastIndexOf","split","length","wispStream","oldWS","onclose","event","emit","code","onopen","partialPacket","onmessage","async","navigator","locks","request","selfPacket","Uint8Array","data","res","readVarInt","packetLen","packetOff","packetIdVI","packetId","packetIdOff","packet","dataLenVI","dataLen","dataLenOff","compressedPacket","chunks","push","stream","Blob","decompressedStream","pipeThrough","DecompressionStream","chunk","e","ba2ab","makeVarInt","PROTOCOL_SERVER_FINISH_LOGIN","p","vi","makeCompressedPacket","makePacket","send","close","ev","toLowerCase","forEach","cb","c","PROTOCOL_CLIENT_VERSION","PROTOCOL_SERVER_VERSION","PROTOCOL_CLIENT_REQUEST_LOGIN","bytes","PROTOCOL_SERVER_ALLOW_LOGIN","PROTOCOL_CLIENT_PROFILE_DATA","PROTOCOL_CLIENT_FINISH_LOGIN","makeString","makeShort","addEventListener","name","callback","removeEventListener","includes","filter","el","window","protos","impl","v","onerror","p1","p2"],"mappings":"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","x_google_ignoreList":[1]}