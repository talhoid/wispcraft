{"version":3,"file":"index.js","sources":["../src/snapshot.js","../node_modules/.pnpm/@mercuryworkshop+wisp-js@0.3.3/node_modules/@mercuryworkshop/wisp-js/src/compat_browser.mjs","../node_modules/.pnpm/@mercuryworkshop+wisp-js@0.3.3/node_modules/@mercuryworkshop/wisp-js/src/packet.mjs","../node_modules/.pnpm/@mercuryworkshop+wisp-js@0.3.3/node_modules/@mercuryworkshop/wisp-js/src/client/connection.mjs","../src/connection.js","../node_modules/.pnpm/@minecraft-js+protocol-1.8@1.0.3/node_modules/@minecraft-js/protocol-1.8/dist/index.js","../src/index.js"],"sourcesContent":["export const nativeWebSocket = WebSocket;","//the node modules referenced by other parts of the code do not exist on the web\n//some of them can be replaced by the standard browser apis, others have to be ignored\n\nexport const WebSocket = globalThis.WebSocket;\nexport const crypto = globalThis.crypto;\nexport const WebSocketServer = null;\nexport const net = null;\nexport const dgram = null;\nexport const dns = null;\nexport const http = null;","//shared packet parsing / serialization code\n\nconst text_encoder = new TextEncoder();\nconst encode_text = text_encoder.encode.bind(text_encoder);\nconst text_decoder = new TextDecoder();\nconst decode_text = text_decoder.decode.bind(text_decoder);\n\nexport class WispBuffer {\n  constructor(data) {\n    if (data instanceof Uint8Array) {\n      this.from_array(data);\n    }\n    else if (typeof data === \"number\") {\n      this.from_array(new Uint8Array(data));\n    }\n    else if (typeof data === \"string\") {\n      this.from_array(encode_text(data));\n    }\n    else {\n      console.trace();\n      throw \"invalid data type passed to wisp buffer constructor\";\n    }\n  }\n\n  from_array(bytes) {\n    this.size = bytes.length;\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer); \n  }\n\n  concat(buffer) {\n    let new_buffer = new WispBuffer(this.size + buffer.size);\n    new_buffer.bytes.set(this.bytes, 0);\n    new_buffer.bytes.set(buffer.bytes, this.size);\n    return new_buffer;\n  }\n\n  slice(index, size) {\n    let bytes_slice = this.bytes.slice(index, size);\n    return new WispBuffer(bytes_slice);\n  }\n}\n\nexport class WispPacket {\n  static min_size = 5;\n  constructor({type, stream_id, payload, payload_bytes }) {\n    this.type = type;\n    this.stream_id = stream_id;\n    this.payload_bytes = payload_bytes;\n    this.payload = payload;\n  }\n  static parse(buffer) {\n    return new WispPacket({\n      type: buffer.view.getUint8(0),\n      stream_id: buffer.view.getUint32(1, true),\n      payload_bytes: buffer.slice(5)\n    });\n  }\n  static parse_all(buffer) {\n    if (buffer.size < WispPacket.min_size) {\n      throw \"packet too small\";\n    }\n    let packet = WispPacket.parse(buffer);\n    let payload_class = packet_classes[packet.type];\n    if (typeof payload_class === \"undefined\") {\n      throw \"invalid packet type\";\n    }\n    if (packet.payload_bytes.size < payload_class.size) {\n      throw \"payload too small\";\n    }\n    packet.payload = payload_class.parse(packet.payload_bytes);\n    return packet;\n  }\n  serialize() {\n    let buffer = new WispBuffer(5);\n    buffer.view.setUint8(0, this.type);\n    buffer.view.setUint32(1, this.stream_id, true);\n    buffer = buffer.concat(this.payload.serialize());\n    return buffer;\n  }\n}\n\nexport class ConnectPayload {\n  static min_size = 3;\n  static type = 0x01;\n  static name = \"CONNECT\";\n  constructor({stream_type, port, hostname}) {\n    this.stream_type = stream_type;\n    this.port = port;\n    this.hostname = hostname;\n  }\n  static parse(buffer) {\n    return new ConnectPayload({\n      stream_type: buffer.view.getUint8(0),\n      port: buffer.view.getUint16(1, true),\n      hostname: decode_text(buffer.slice(3).bytes)\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(3);\n    buffer.view.setUint8(0, this.stream_type);\n    buffer.view.setUint16(1, this.port, true);\n    buffer = buffer.concat(new WispBuffer(this.hostname));\n    return buffer;\n  }\n}\n\nexport class DataPayload {\n  static min_size = 0;\n  static type = 0x02;\n  static name = \"DATA\";\n  constructor({data}) {\n    this.data = data;\n  }\n  static parse(buffer) {\n    return new DataPayload({\n      data: buffer\n    });\n  }\n  serialize() {\n    return this.data;\n  }\n}\n\nexport class ContinuePayload {\n  static type = 0x03;\n  static name = \"CONTINUE\";\n  constructor({buffer_remaining}) {\n    this.buffer_remaining = buffer_remaining;\n  }\n  static parse(buffer) {\n    return new ContinuePayload({\n      buffer_remaining: buffer.view.getUint32(0, true),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(4);\n    buffer.view.setUint32(0, this.buffer_remaining, true);\n    return buffer;\n  }\n}\n\nexport class ClosePayload {\n  static min_size = 1;\n  static type = 0x04;\n  static name = \"CLOSE\";\n  constructor({reason}) {\n    this.reason = reason;\n  }\n  static parse(buffer) {\n    return new ClosePayload({\n      reason: buffer.view.getUint8(0),\n    });\n  }\n  serialize() {\n    let buffer = new WispBuffer(1);\n    buffer.view.setUint8(0, this.reason);\n    return buffer;\n  }\n}\n\nexport const packet_classes = [\n  undefined,\n  ConnectPayload, \n  DataPayload, \n  ContinuePayload, \n  ClosePayload\n]\n\nexport const packet_types = {\n  CONNECT: 0x01,\n  DATA: 0x02,\n  CONTINUE: 0x03,\n  CLOSE: 0x04\n}\n\nexport const stream_types = {\n  TCP: 0x01,\n  UDP: 0x02\n}\n\nexport const close_reasons = {\n  //client/server close reasons\n  Unknown: 0x01,\n  Voluntary: 0x02,\n  NetworkError: 0x03,\n\n  //server only close reasons\n  InvalidInfo: 0x41, \n  UnreachableHost: 0x42,\n  NoResponse: 0x43,\n  ConnRefused: 0x44,\n  TransferTimeout: 0x47,\n  HostBlocked: 0x48,\n  ConnThrottled: 0x49,\n\n  //client only close reasons\n  ClientError: 0x81\n}","import * as compat from \"../compat.mjs\";\n\nimport {\n  packet_classes,\n  packet_types,\n  stream_types,\n  WispBuffer, \n  WispPacket, \n  ConnectPayload, \n  DataPayload, \n  ClosePayload\n} from \"../packet.mjs\";\n\nclass ClientStream {\n  constructor(hostname, port, websocket, buffer_size, stream_id, connection, stream_type) {\n    this.hostname = hostname;\n    this.port = port;\n    this.ws = websocket;\n    this.buffer_size = buffer_size;\n    this.stream_id = stream_id;\n    this.connection = connection;\n    this.stream_type = stream_type;\n    this.send_buffer = [];\n    this.open = true;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onmessage = () => {};\n  }\n\n  send(data) {\n    //note: udp shouldn't buffer anything\n    if (this.buffer_size > 0 || !this.open || this.stream_type === stream_types.UDP) {\n      //construct and send a DATA packet\n      let packet = new WispPacket({\n        type: packet_types.DATA,\n        stream_id: this.stream_id,\n        payload: new DataPayload({\n          data: new WispBuffer(data)\n        })\n      });\n      this.ws.send(packet.serialize().bytes);\n      this.buffer_size--;\n    }\n    else { //server is slow, don't send data yet\n      this.send_buffer.push(data);\n    }\n  }\n\n  //handle receiving a CONTINUE packet\n  continue_received(buffer_size) {\n    this.buffer_size = buffer_size;\n    //send buffered data now\n    while (this.buffer_size > 0 && this.send_buffer.length > 0) {\n      this.send(this.send_buffer.shift());\n    }\n  }\n\n  //construct and send a CLOSE packet\n  close(reason = 0x01) {\n    if (!this.open) return;\n    let packet = new WispPacket({\n      type: packet_types.CLOSE,\n      stream_id: stream_id,\n      payload: new ClosePayload({\n        reason: reason\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    this.open = false;\n    delete this.connection.active_streams[this.stream_id];\n  }\n}\n\nexport class ClientConnection {\n  constructor(wisp_url) {\n    if (!wisp_url.endsWith(\"/\")) {\n      throw \"wisp endpoints must end with a trailing forward slash\";\n    }\n\n    this.wisp_url = wisp_url;\n    this.max_buffer_size = null;\n    this.active_streams = {};\n    this.connected = false;\n    this.connecting = false;\n    this.next_stream_id = 1;\n\n    this.onopen = () => {};\n    this.onclose = () => {};\n    this.onerror = () => {};\n    this.onmessage = () => {};\n\n    this.connect_ws();\n  }\n\n  connect_ws() {\n    this.ws = new compat.WebSocket(this.wisp_url);\n    this.ws.binaryType = \"arraybuffer\";\n    this.connecting = true;\n\n    this.ws.onerror = () => {\n      this.on_ws_close();\n      this.onerror();\n    };\n    this.ws.onclose = () => {\n      this.on_ws_close();\n      this.onclose();\n    };\n    this.ws.onmessage = (event) => {\n      this.on_ws_msg(event);\n      if (this.connecting) {\n        this.connected = true;\n        this.connecting = false;\n        this.onopen();\n      }\n    };\n  }\n\n  close_stream(stream, reason) {\n    stream.onclose(reason);\n    delete this.active_streams[stream.stream_id];\n  }\n\n  on_ws_close() {\n    this.connected = false;\n    this.connecting = false;\n    for (let stream_id of Object.keys(this.active_streams)) {\n      this.close_stream(this.active_streams[stream_id], 0x03);\n    }\n  }\n\n  create_stream(hostname, port, type=\"tcp\") {\n    let stream_type = type === \"udp\" ? 0x02 : 0x01;\n    let stream_id = this.next_stream_id++;\n    let stream = new ClientStream(hostname, port, this.ws, this.max_buffer_size, stream_id, this, stream_type);\n    this.active_streams[stream_id] = stream;\n    stream.open = this.connected;\n\n    //construct CONNECT packet\n    let packet = new WispPacket({\n      type: packet_types.CONNECT,\n      stream_id: stream_id,\n      payload: new ConnectPayload({\n        stream_type: stream_type,\n        port: port,\n        hostname: hostname\n      })\n    });\n    this.ws.send(packet.serialize().bytes);\n    return stream;\n  }\n\n  on_ws_msg(event) {\n    let buffer = new WispBuffer(new Uint8Array(event.data));\n    if (buffer.size < WispPacket.min_size) {\n      console.warn(`wisp client warning: received a packet which is too short`);\n      return;\n    }\n    let packet = WispPacket.parse_all(buffer);\n    let stream = this.active_streams[packet.stream_id];\n\n    if (typeof stream === \"undefined\" && (packet.stream_id !== 0 || packet.type !== packet_types.CONTINUE)) {\n      console.warn(`wisp client warning: received a ${packet_classes[packet.type].name} packet for a stream which doesn't exist`);\n      return;\n    }\n\n    if (packet.type === packet_types.DATA) { //DATA packets\n      stream.onmessage(packet.payload_bytes.bytes);\n    }\n\n    else if (packet.type === packet_types.CONTINUE && packet.stream_id == 0) { //initial CONTINUE packet\n      this.max_buffer_size = packet.payload.buffer_remaining;\n    }\n\n    else if (packet.type === packet_types.CONTINUE) { //other CONTINUE packets\n      stream.continue_received(packet.payload.buffer_size);\n    }\n\n    else if (packet.type === packet_types.CLOSE) { //CLOSE packets\n      this.close_stream(stream, packet.payload.reason);\n    }\n\n    else {\n      console.warn(`wisp client warning: receive an invalid packet of type ${packet.type}`);\n    }\n  }\n}\n\n","import { client as wisp } from \"@mercuryworkshop/wisp-js/client\";\n\nexport class wispWS {\n    constructor(uri) {\n        this.binaryType = \"blob\";\n        this.readyState = \"\";\n        this.url = uri;\n        this.eventListeners = [];\n        this.handshook = false;\n        this.loggedIn = false;\n        this.compression = -1;\n        this.eag2wispQueue = [];\n        this.username = \"___\";\n        this.ipPort = uri.slice(uri.lastIndexOf(\"/\") + 1).split(\":\", 2);\n        if (this.ipPort.length < 2 || !+this.ipPort[1]) {\n            this.ipPort[1] = 25565;\n        }\n        this.ipPort[1] = +this.ipPort[1];\n        const conn = new wisp.ClientConnection(\"ws://localhost:3000/\");\n        conn.addEventListener(\"open\", () => {\n            let partialPacket = [];\n            this.wispStream = conn.create_stream(this.ipPort[0], this.ipPort[1]);\n            this.wispStream.addEventListener(\"message\", async (event) => {\n                const selfPacket = [...partialPacket, ...event.data];\n                partialPacket = [];\n                const res = readVarInt(selfPacket);\n                if (res.length < 2) {\n                    partialPacket = selfPacket;\n                    return;\n                }\n                const packetLen = res[0];\n                const packetOff = res[1];\n                if (selfPacket.length < packetOff + packetLen) {\n                    partialPacket = selfPacket;\n                    return;\n                }\n                let packetIdVI, packetId, packetIdOff, packet;\n                if (this.compression >= 0) {\n                    const dataLenVI = readVarInt(selfPacket.slice(packetOff, packetOff + packetLen));\n                    if (dataLenVI.length < 2) {\n                        partialPacket = selfPacket;\n                        return;\n                    }\n                    let dataLen = dataLenVI[0];\n                    const dataLenOff = dataLenVI[1];\n                    const compressedPacket = selfPacket.slice(packetOff + dataLenOff, packetOff + packetLen);\n                    const chunks = [];\n                    if (dataLen == 0) {\n                        dataLen = packetLen - dataLenOff;\n                        chunks.push(...compressedPacket);\n                    } else {\n                        const stream = new Blob([new Uint8Array(ba2ab(compressedPacket))]).stream();\n                        try {\n                            const decompressedStream = stream.pipeThrough(\n                                new DecompressionStream(\"deflate\")\n                            );\n                            for await (const chunk of decompressedStream) {\n                                chunks.push(...chunk);\n                            }\n                        } catch (e) {\n                            partialPacket = selfPacket;\n                            return;\n                        }\n                    }\n                    if (chunks.length != dataLen) {\n                        console.info(chunks.length + \" \" + dataLen);\n                        partialPacket = selfPacket;\n                        return;\n                    }\n                    packetIdVI = readVarInt(chunks.slice(0, dataLen));\n                    if (packetIdVI.length < 2) {\n                        partialPacket = selfPacket;\n                        return;\n                    }\n                    packetId = packetIdVI[0];\n                    packetIdOff = packetIdVI[1];\n                    packet = chunks.slice(packetIdOff, dataLen);\n                    partialPacket = selfPacket.slice(packetOff + dataLenOff + compressedPacket.length);\n                } else {\n                    packetIdVI = readVarInt(selfPacket.slice(packetOff, packetOff + packetLen));\n                    if (packetIdVI.length < 2) {\n                        partialPacket = selfPacket;\n                        return;\n                    }\n                    packetId = packetIdVI[0];\n                    packetIdOff = packetIdVI[1];\n                    packet = selfPacket.slice(packetOff + packetIdOff, packetOff + packetLen);\n                    partialPacket = selfPacket.slice(packetOff + packetLen);\n                }\n                if (this.loggedIn) {\n                    if (packetId == 0x46) {\n                        this.compression = readVarInt(packet)[0];\n                    } else {\n                        this.emit(\"message\", {data: ba2ab([...makeVarInt(packetId), ...packet])});\n                    }\n                } else if (packetId == 0x03) {\n                    this.compression = readVarInt(packet)[0];\n                } else if (packetId == 0x02) {\n                    this.emit(\"message\", {data: ba2ab([PROTOCOL_SERVER_FINISH_LOGIN])});\n                    this.loggedIn = true;\n                    for (let p of this.eag2wispQueue) {\n                        const vi = readVarInt(p);\n                        if (this.compression >= 0) {\n                            p = new Uint8Array(ba2ab(await makeCompressedPacket(vi[0], p.slice(vi[1]), this.compression)));\n                        } else {\n                            p = new Uint8Array(ba2ab(makePacket(vi[0], p.slice(vi[1]))));\n                        }\n                        this.wispStream.send(p);\n                    }\n                    this.eag2wispQueue = [];\n                } else if (packetId == 0x00) {\n                    this.wispStream.close();\n                }\n            });\n            this.wispStream.addEventListener(\"close\", (event) => {\n                this.emit(\"close\", event.code);\n                conn.close();\n            });\n            this.emit(\"open\", {});\n        });\n    }\n    emit(ev, data) {\n        ev = ev.toLowerCase();\n        if (this[\"on\" + ev]) {\n            this[\"on\" + ev](data);\n        }\n        if (this.eventListeners[ev]) {\n            this.eventListeners[ev].forEach(cb => cb(data));\n        }\n    }\n    close(c) {\n        if (this.wispStream) {\n            this.wispStream.close(c);\n        }\n    }\n    async send(p) {\n        if (this.wispStream) {\n            if (!this.handshook) {\n                switch (p[0]) {\n                    case PROTOCOL_CLIENT_VERSION:\n                        this.emit(\"message\", {data: ba2ab([PROTOCOL_SERVER_VERSION, 0, 3, 0, 47, 0, 0, 0, 0, 0])});\n                        break;\n                    case PROTOCOL_CLIENT_REQUEST_LOGIN:\n                        const bytes = p.slice(2, p[1] + 2);\n                        this.username = new TextDecoder().decode(bytes);\n                        // in line below: need to replace the 16 bytes with OfflinePlayer:(username) UUID in form of 8-byte long MSB, 8-byte long LSB\n                        this.emit(\"message\", {data: ba2ab([PROTOCOL_SERVER_ALLOW_LOGIN, this.username.length, ...bytes, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])});\n                        break;\n                    case PROTOCOL_CLIENT_PROFILE_DATA:\n                        // ignore for now\n                        break;\n                    case PROTOCOL_CLIENT_FINISH_LOGIN:\n                        this.handshook = true;\n                        this.wispStream.send(new Uint8Array(ba2ab(makePacket(0x00, [...makeVarInt(47), ...makeString(this.ipPort[0]), ...makeShort(this.ipPort[1]), ...makeVarInt(2)]))));\n                        this.wispStream.send(new Uint8Array(ba2ab(makePacket(0x00, [...makeString(this.username)]))));\n                        break;\n                    default:\n                }\n                return;\n            }\n            if (this.loggedIn) {\n                const vi = readVarInt(p);\n                if (this.compression >= 0) {\n                    p = new Uint8Array(ba2ab(await makeCompressedPacket(vi[0], p.slice(vi[1]), this.compression)));\n                } else {\n                    p = new Uint8Array(ba2ab(makePacket(vi[0], p.slice(vi[1]))));\n                }\n                this.wispStream.send(p);\n            } else {\n                this.eag2wispQueue.push(p);\n            }\n        }\n    }\n    addEventListener(name, cb) {\n        name = name.toLowerCase();\n        if (this.eventListeners[name]) {\n            this.eventListeners[name].push(callback);\n        } else {\n            this.eventListeners[name] = [cb];\n        }\n    }\n    removeEventListener(name, cb) {\n        name = name.toLowerCase();\n        if (this.eventListeners[name]) {\n            if (cb && this.eventListeners[name].includes(cb)) {\n                this.eventListeners[name] = this.eventListeners[name].filter((el) => el != cb);\n                if (this.eventListeners[name].length == 0) {\n                    delete this.eventListeners[name];\n                }\n            } else if (!cb) {\n                delete this.eventListeners[name];\n            }\n            \n        }\n    }\n};","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n__exportStar(require(\"./client/Client\"), exports);\r\n__exportStar(require(\"./protocol\"), exports);\r\n__exportStar(require(\"./server/Client\"), exports);\r\n__exportStar(require(\"./server/Server\"), exports);\r\n","import { nativeWebSocket } from \"./snapshot\";\nimport { wispWS } from \"./connection\";\nimport \"@minecraft-js/protocol-1.8\";\nwindow.WebSocket = class {\n    constructor(uri, protos) {\n        if ((\"\" + uri).toLowerCase().includes(\"://java://\")) {\n            this.impl = new wispWS(uri);\n        } else {\n            this.impl = new nativeWebSocket(uri, protos);\n        }\n    }\n    get binaryType() {\n        return this.impl.binaryType;\n    }\n    set binaryType(v) {\n        this.impl.binaryType = v;\n    }\n    get readyState() {\n        return this.impl.readyState;\n    }\n    get url() {\n        return this.impl.url;\n    }\n    set onopen(v) {\n        this.impl.onopen = v;\n    }\n    set onclose(v) {\n        this.impl.onclose = v;\n    }\n    set onmessage(v) {\n        this.impl.onmessage = v;\n    }\n    set onerror(v) {\n        this.impl.onerror = v;\n    }\n    close(c) {\n        return this.impl.close(c);\n    }\n    send(p) {\n        return this.impl.send(p);\n    }\n    addEventListener(p1, p2) {\n        return this.impl.addEventListener(p1, p2);\n    }\n    removeEventListener(p1, p2) {\n        return this.impl.removeEventListener(p1, p2);\n    }\n};"],"names":["nativeWebSocket","WebSocket","globalThis","text_encoder","TextEncoder","encode_text","encode","bind","text_decoder","TextDecoder","decode_text","decode","WispBuffer","constructor","data","Uint8Array","this","from_array","console","trace","bytes","size","length","view","DataView","buffer","concat","new_buffer","set","slice","index","bytes_slice","WispPacket","static","type","stream_id","payload","payload_bytes","parse","getUint8","getUint32","parse_all","min_size","packet","payload_class","packet_classes","serialize","setUint8","setUint32","ConnectPayload","stream_type","port","hostname","getUint16","setUint16","DataPayload","ContinuePayload","buffer_remaining","ClosePayload","reason","undefined","packet_types","stream_types","ClientStream","websocket","buffer_size","connection","ws","send_buffer","open","onopen","onclose","onmessage","send","push","continue_received","shift","close","active_streams","ClientConnection","wisp_url","endsWith","max_buffer_size","connected","connecting","next_stream_id","onerror","connect_ws","compat.WebSocket","binaryType","on_ws_close","event","on_ws_msg","close_stream","stream","Object","keys","create_stream","warn","name","wispWS","uri","readyState","url","eventListeners","handshook","loggedIn","compression","eag2wispQueue","username","ipPort","lastIndexOf","split","conn","wisp.ClientConnection","addEventListener","partialPacket","wispStream","async","selfPacket","res","readVarInt","packetLen","packetOff","packetIdVI","packetId","packetIdOff","dataLenVI","dataLen","dataLenOff","compressedPacket","chunks","Blob","ba2ab","decompressedStream","pipeThrough","DecompressionStream","chunk","e","info","emit","makeVarInt","PROTOCOL_SERVER_FINISH_LOGIN","p","vi","makeCompressedPacket","makePacket","code","ev","toLowerCase","forEach","cb","c","PROTOCOL_CLIENT_VERSION","PROTOCOL_SERVER_VERSION","PROTOCOL_CLIENT_REQUEST_LOGIN","PROTOCOL_SERVER_ALLOW_LOGIN","PROTOCOL_CLIENT_PROFILE_DATA","PROTOCOL_CLIENT_FINISH_LOGIN","makeString","makeShort","callback","removeEventListener","includes","filter","el","__createBinding","create","o","m","k","k2","desc","getOwnPropertyDescriptor","__esModule","writable","configurable","enumerable","get","defineProperty","__exportStar","exports","prototype","hasOwnProperty","call","value","require","window","protos","impl","v","p1","p2"],"mappings":"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","x_google_ignoreList":[1,2,3,5]}