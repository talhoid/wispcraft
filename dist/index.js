!function(e){"function"==typeof define&&define.amd?define(e):e()}((function(){"use strict";const e=WebSocket,t=globalThis.WebSocket,s=new TextEncoder,i=s.encode.bind(s),n=new TextDecoder,r=n.decode.bind(n);class a{constructor(e){if(e instanceof Uint8Array)this.from_array(e);else if("number"==typeof e)this.from_array(new Uint8Array(e));else{if("string"!=typeof e)throw console.trace(),"invalid data type passed to wisp buffer constructor";this.from_array(i(e))}}from_array(e){this.size=e.length,this.bytes=e,this.view=new DataView(e.buffer)}concat(e){let t=new a(this.size+e.size);return t.bytes.set(this.bytes,0),t.bytes.set(e.bytes,this.size),t}slice(e,t){let s=this.bytes.slice(e,t);return new a(s)}}class o{static min_size=5;constructor({type:e,stream_id:t,payload:s,payload_bytes:i}){this.type=e,this.stream_id=t,this.payload_bytes=i,this.payload=s}static parse(e){return new o({type:e.view.getUint8(0),stream_id:e.view.getUint32(1,!0),payload_bytes:e.slice(5)})}static parse_all(e){if(e.size<o.min_size)throw"packet too small";let t=o.parse(e),s=d[t.type];if(void 0===s)throw"invalid packet type";if(t.payload_bytes.size<s.size)throw"payload too small";return t.payload=s.parse(t.payload_bytes),t}serialize(){let e=new a(5);return e.view.setUint8(0,this.type),e.view.setUint32(1,this.stream_id,!0),e=e.concat(this.payload.serialize()),e}}class h{static min_size=3;static type=1;static name="CONNECT";constructor({stream_type:e,port:t,hostname:s}){this.stream_type=e,this.port=t,this.hostname=s}static parse(e){return new h({stream_type:e.view.getUint8(0),port:e.view.getUint16(1,!0),hostname:r(e.slice(3).bytes)})}serialize(){let e=new a(3);return e.view.setUint8(0,this.stream_type),e.view.setUint16(1,this.port,!0),e=e.concat(new a(this.hostname)),e}}class c{static min_size=0;static type=2;static name="DATA";constructor({data:e}){this.data=e}static parse(e){return new c({data:e})}serialize(){return this.data}}class l{static type=3;static name="CONTINUE";constructor({buffer_remaining:e}){this.buffer_remaining=e}static parse(e){return new l({buffer_remaining:e.view.getUint32(0,!0)})}serialize(){let e=new a(4);return e.view.setUint32(0,this.buffer_remaining,!0),e}}class p{static min_size=1;static type=4;static name="CLOSE";constructor({reason:e}){this.reason=e}static parse(e){return new p({reason:e.view.getUint8(0)})}serialize(){let e=new a(1);return e.view.setUint8(0,this.reason),e}}const d=[void 0,h,c,l,p],m=1,w=2,_=3,u=4,f=2;class y{constructor(e,t,s,i,n,r,a){this.hostname=e,this.port=t,this.ws=s,this.buffer_size=i,this.stream_id=n,this.connection=r,this.stream_type=a,this.send_buffer=[],this.open=!0,this.onopen=()=>{},this.onclose=()=>{},this.onmessage=()=>{}}send(e){if(this.buffer_size>0||!this.open||this.stream_type===f){let t=new o({type:w,stream_id:this.stream_id,payload:new c({data:new a(e)})});this.ws.send(t.serialize().bytes),this.buffer_size--}else this.send_buffer.push(e)}continue_received(e){for(this.buffer_size=e;this.buffer_size>0&&this.send_buffer.length>0;)this.send(this.send_buffer.shift())}close(e=1){if(!this.open)return;let t=new o({type:u,stream_id:stream_id,payload:new p({reason:e})});this.ws.send(t.serialize().bytes),this.open=!1,delete this.connection.active_streams[this.stream_id]}}class b{constructor(e){if(!e.endsWith("/"))throw"wisp endpoints must end with a trailing forward slash";this.wisp_url=e,this.max_buffer_size=null,this.active_streams={},this.connected=!1,this.connecting=!1,this.next_stream_id=1,this.onopen=()=>{},this.onclose=()=>{},this.onerror=()=>{},this.onmessage=()=>{},this.connect_ws()}connect_ws(){this.ws=new t(this.wisp_url),this.ws.binaryType="arraybuffer",this.connecting=!0,this.ws.onerror=()=>{this.on_ws_close(),this.onerror()},this.ws.onclose=()=>{this.on_ws_close(),this.onclose()},this.ws.onmessage=e=>{this.on_ws_msg(e),this.connecting&&(this.connected=!0,this.connecting=!1,this.onopen())}}close_stream(e,t){e.onclose(t),delete this.active_streams[e.stream_id]}on_ws_close(){this.connected=!1,this.connecting=!1;for(let e of Object.keys(this.active_streams))this.close_stream(this.active_streams[e],3)}create_stream(e,t,s="tcp"){let i="udp"===s?2:1,n=this.next_stream_id++,r=new y(e,t,this.ws,this.max_buffer_size,n,this,i);this.active_streams[n]=r,r.open=this.connected;let a=new o({type:m,stream_id:n,payload:new h({stream_type:i,port:t,hostname:e})});return this.ws.send(a.serialize().bytes),r}on_ws_msg(e){let t=new a(new Uint8Array(e.data));if(t.size<o.min_size)return void console.warn("wisp client warning: received a packet which is too short");let s=o.parse_all(t),i=this.active_streams[s.stream_id];void 0!==i||0===s.stream_id&&s.type===_?s.type===w?i.onmessage(s.payload_bytes.bytes):s.type===_&&0==s.stream_id?this.max_buffer_size=s.payload.buffer_remaining:s.type===_?i.continue_received(s.payload.buffer_size):s.type===u?this.close_stream(i,s.payload.reason):console.warn(`wisp client warning: receive an invalid packet of type ${s.type}`):console.warn(`wisp client warning: received a ${d[s.type].name} packet for a stream which doesn't exist`)}}class v{constructor(e){this.binaryType="blob",this.readyState="",this.url=e,this.eventListeners=[],this.handshook=!1,this.loggedIn=!1,this.compression=-1,this.eag2wispQueue=[],this.username="___",this.ipPort=e.slice(e.lastIndexOf("/")+1).split(":",2),(this.ipPort.length<2||!+this.ipPort[1])&&(this.ipPort[1]=25565),this.ipPort[1]=+this.ipPort[1];const t=new b("ws://localhost:3000/");t.addEventListener("open",(()=>{let e=[];this.wispStream=t.create_stream(this.ipPort[0],this.ipPort[1]),this.wispStream.addEventListener("message",(async t=>{const s=[...e,...t.data];e=[];const i=readVarInt(s);if(i.length<2)return void(e=s);const n=i[0],r=i[1];if(s.length<r+n)return void(e=s);let a,o,h,c;if(this.compression>=0){const t=readVarInt(s.slice(r,r+n));if(t.length<2)return void(e=s);let i=t[0];const l=t[1],p=s.slice(r+l,r+n),d=[];if(0==i)i=n-l,d.push(...p);else{const t=new Blob([new Uint8Array(ba2ab(p))]).stream();try{const e=t.pipeThrough(new DecompressionStream("deflate"));for await(const t of e)d.push(...t)}catch(t){return void(e=s)}}if(d.length!=i)return console.info(d.length+" "+i),void(e=s);if(a=readVarInt(d.slice(0,i)),a.length<2)return void(e=s);o=a[0],h=a[1],c=d.slice(h,i),e=s.slice(r+l+p.length)}else{if(a=readVarInt(s.slice(r,r+n)),a.length<2)return void(e=s);o=a[0],h=a[1],c=s.slice(r+h,r+n),e=s.slice(r+n)}if(this.loggedIn)70==o?this.compression=readVarInt(c)[0]:this.emit("message",{data:ba2ab([...makeVarInt(o),...c])});else if(3==o)this.compression=readVarInt(c)[0];else if(2==o){this.emit("message",{data:ba2ab([PROTOCOL_SERVER_FINISH_LOGIN])}),this.loggedIn=!0;for(let e of this.eag2wispQueue){const t=readVarInt(e);e=this.compression>=0?new Uint8Array(ba2ab(await makeCompressedPacket(t[0],e.slice(t[1]),this.compression))):new Uint8Array(ba2ab(makePacket(t[0],e.slice(t[1])))),this.wispStream.send(e)}this.eag2wispQueue=[]}else 0==o&&this.wispStream.close()})),this.wispStream.addEventListener("close",(e=>{this.emit("close",e.code),t.close()})),this.emit("open",{})}))}emit(e,t){this["on"+(e=e.toLowerCase())]&&this["on"+e](t),this.eventListeners[e]&&this.eventListeners[e].forEach((e=>e(t)))}close(e){this.wispStream&&this.wispStream.close(e)}async send(e){if(this.wispStream){if(!this.handshook){switch(e[0]){case PROTOCOL_CLIENT_VERSION:this.emit("message",{data:ba2ab([PROTOCOL_SERVER_VERSION,0,3,0,47,0,0,0,0,0])});break;case PROTOCOL_CLIENT_REQUEST_LOGIN:const t=e.slice(2,e[1]+2);this.username=(new TextDecoder).decode(t),this.emit("message",{data:ba2ab([PROTOCOL_SERVER_ALLOW_LOGIN,this.username.length,...t,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0])});break;case PROTOCOL_CLIENT_PROFILE_DATA:break;case PROTOCOL_CLIENT_FINISH_LOGIN:this.handshook=!0,this.wispStream.send(new Uint8Array(ba2ab(makePacket(0,[...makeVarInt(47),...makeString(this.ipPort[0]),...makeShort(this.ipPort[1]),...makeVarInt(2)])))),this.wispStream.send(new Uint8Array(ba2ab(makePacket(0,[...makeString(this.username)]))))}return}if(this.loggedIn){const t=readVarInt(e);e=this.compression>=0?new Uint8Array(ba2ab(await makeCompressedPacket(t[0],e.slice(t[1]),this.compression))):new Uint8Array(ba2ab(makePacket(t[0],e.slice(t[1])))),this.wispStream.send(e)}else this.eag2wispQueue.push(e)}}addEventListener(e,t){e=e.toLowerCase(),this.eventListeners[e]?this.eventListeners[e].push(callback):this.eventListeners[e]=[t]}removeEventListener(e,t){e=e.toLowerCase(),this.eventListeners[e]&&(t&&this.eventListeners[e].includes(t)?(this.eventListeners[e]=this.eventListeners[e].filter((e=>e!=t)),0==this.eventListeners[e].length&&delete this.eventListeners[e]):t||delete this.eventListeners[e])}}var g=Object.create?function(e,t,s,i){void 0===i&&(i=s);var n=Object.getOwnPropertyDescriptor(t,s);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[s]}}),Object.defineProperty(e,i,n)}:function(e,t,s,i){void 0===i&&(i=s),e[i]=t[s]},L=function(e,t){for(var s in e)"default"===s||Object.prototype.hasOwnProperty.call(t,s)||g(t,e,s)};Object.defineProperty(exports,"__esModule",{value:!0}),L(require("./client/Client"),exports),L(require("./protocol"),exports),L(require("./server/Client"),exports),L(require("./server/Server"),exports),window.WebSocket=class{constructor(t,s){(""+t).toLowerCase().includes("://java://")?this.impl=new v(t):this.impl=new e(t,s)}get binaryType(){return this.impl.binaryType}set binaryType(e){this.impl.binaryType=e}get readyState(){return this.impl.readyState}get url(){return this.impl.url}set onopen(e){this.impl.onopen=e}set onclose(e){this.impl.onclose=e}set onmessage(e){this.impl.onmessage=e}set onerror(e){this.impl.onerror=e}close(e){return this.impl.close(e)}send(e){return this.impl.send(e)}addEventListener(e,t){return this.impl.addEventListener(e,t)}removeEventListener(e,t){return this.impl.removeEventListener(e,t)}}}));
//# sourceMappingURL=index.js.map
